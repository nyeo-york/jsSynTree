<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>jsSynTree 1.0</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
            background-color: #f5f5f5;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .toolbar {
            background: #333;
            color: white;
            padding: 10px 20px;
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap; 
        }
        
        .toolbar-section {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .toolbar-section label {
            white-space: nowrap;
            font-size: 14px;
            margin: 0;
        }
        
        button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            background: #4CAF50;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        button:hover:not(:disabled) {
            background: #45a049;
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.7;
        }
        
        button.active {
            background: #2196F3;
        }
        
        button.danger {
            background: #f44336;
        }
        
        button.danger:hover:not(:disabled) {
            background: #da190b;
        }
        
        select, input[type="checkbox"], input[type="number"] {
            padding: 6px;
            border-radius: 4px;
            border: 1px solid #ddd;
            font-size: 14px;
            vertical-align: middle;
        }
        input[type="checkbox"] {
             margin-right: 4px;
        }
        input[type="number"] {
            background: white;
            color: #333;
        }
        
        #canvas {
            display: block;
            cursor: crosshair;
            background: white;
            border: 1px solid #ddd;
            margin: 0 auto;
        }
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center; 
            justify-content: center; 
        }
        
        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            width: 90%; 
            max-width: 500px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .modal-content h3 {
            margin-top: 0;
        }
        
        .modal-content textarea, .modal-content select {
            width: calc(100% - 18px);
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            box-sizing: border-box; 
            font-size: 14px;
        }
         .modal-content textarea {
             resize: vertical;
         }
        .modal-content label {
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }
        
        .formatting-help {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-size: 12px;
            font-family: monospace;
        }
        
        .formatting-help h4 {
            margin: 0 0 8px 0;
            font-size: 13px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
        }
        
        .formatting-buttons {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        
        .formatting-buttons button {
            padding: 4px 8px;
            font-size: 12px;
            background-color: #e9ecef;
            color: #495057;
            border: 1px solid #ced4da;
        }
        
        .formatting-buttons button:hover {
            background-color: #dee2e6;
        }
        
        .modal-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }
        
        .info {
            background: #e3f2fd;
            padding: 10px 20px;
            font-size: 14px;
            color: #1976d2;
            border-bottom: 1px solid #bbdefb;
        }

    </style>
</head>
<body>    
    <div class="container">
        <div class="toolbar">
            <div class="toolbar-section">
                <button id="addNodeBtn" class="active">Add Node</button>
                <button id="connectBtn">Connect</button>
                <button id="selectBtn">Select/Move</button>
                <button id="addMovementBtn">Add Movement</button>
            </div>
            
            <div class="toolbar-section">
                 <input type="checkbox" id="gridCheckbox" checked>
                 <label for="gridCheckbox" style="color:white; font-size:14px;">Show Grid</label>
            </div>
            
            <div class="toolbar-section">
                <button id="undoBtn">Undo</button>
                <button id="deleteBtn" class="danger">Delete Selected</button>
                <button id="clearBtn" class="danger">Clear All</button>
            </div>
            
            <div class="toolbar-section">
                <label for="canvasWidth" style="color:white; font-size:14px;">Width:</label>
                <input type="number" id="canvasWidth" min="400" max="3000" step="50" value="1200" style="width:70px;">
                <label for="canvasHeight" style="color:white; font-size:14px;">Height:</label>
                <input type="number" id="canvasHeight" min="300" max="2000" step="50" value="600" style="width:70px;">
                <button id="autoFitBtn">Auto Fit</button>
            </div>
            
            <div class="toolbar-section">
                <button id="exportBtn">Export PNG</button>
                <button id="saveTreeBtn">Save Tree</button>
                <button id="loadTreeBtn">Load Tree</button>
                <input type="file" id="loadTreeInput" style="display: none;" accept=".json,.tree">
            </div>
        </div>
        
        <div class="info">
            Click to add nodes • Double-click to edit text • If using buttons for formatting, highlight text then click button • Click Select then drag to move • Ctrl+Click to select node and all daughters • Click on mother then daughter to attach connector • Select movement arrow and drag control point to adjust curvature • Esc = Cancel • Del = Delete • Save Tree to JSON
        </div>
        
        <canvas id="canvas"></canvas>
    </div>
    
    <div id="textModal" class="modal">
        <div class="modal-content">
            <h3>Edit Node</h3>
            
            <label for="nodeText">Node Text:</label>
            <div class="formatting-help">
                <h4>Formatting Syntax:</h4>
                **bold** • *italic* • ~strikethrough~ • ^superscript^ • _subscript_ • [SC]small caps[/SC] • [SIZE=14]font size[/SIZE]
            </div>
            <div class="formatting-buttons">
                <button onclick="insertFormatting('nodeText', '**', '**')">Bold</button>
                <button onclick="insertFormatting('nodeText', '*', '*')">Italic</button>
                <button onclick="insertFormatting('nodeText', '~', '~')">Strike</button>
                <button onclick="insertFormatting('nodeText', '^', '^')">Super</button>
                <button onclick="insertFormatting('nodeText', '_', '_')">Sub</button>
                <button onclick="insertFormatting('nodeText', '[SC]', '[/SC]')">SC</button>
            </div>
            <div class="formatting-buttons" style="margin-top: 5px;">
                <label style="display: inline; margin: 0 5px 0 0; font-size: 12px; font-weight: normal;">Size:</label>
                <input type="number" id="nodeFontSize" min="8" max="32" value="16" style="width: 50px; padding: 2px; font-size: 12px; margin-right: 5px;">
                <button onclick="applySizeFormatting('nodeText', document.getElementById('nodeFontSize').value)">Apply</button>
                <button onclick="insertFormatting('nodeText', '[SIZE=12]', '[/SIZE]')">Small</button>
                <button onclick="insertFormatting('nodeText', '[SIZE=16]', '[/SIZE]')">Normal</button>
                <button onclick="insertFormatting('nodeText', '[SIZE=20]', '[/SIZE]')">Large</button>
            </div>
            <textarea id="nodeText" rows="4" placeholder="Enter node text with formatting"></textarea>
            
            <label for="nodeFeatures">Syntactic Features:</label>
            <div class="formatting-buttons">
                <button onclick="insertFormatting('nodeFeatures', '**', '**')">Bold</button>
                <button onclick="insertFormatting('nodeFeatures', '*', '*')">Italic</button>
                <button onclick="insertFormatting('nodeFeatures', '~', '~')">Strike</button>
                <button onclick="insertFormatting('nodeFeatures', '^', '^')">Super</button>
                <button onclick="insertFormatting('nodeFeatures', '_', '_')">Sub</button>
                <button onclick="insertFormatting('nodeFeatures', '[SC]', '[/SC]')">SC</button>
            </div>
            <div class="formatting-buttons" style="margin-top: 5px;">
                <label style="display: inline; margin: 0 5px 0 0; font-size: 12px; font-weight: normal;">Size:</label>
                <input type="number" id="featureFontSize" min="8" max="32" value="14" style="width: 50px; padding: 2px; font-size: 12px; margin-right: 5px;">
                <button onclick="applySizeFormatting('nodeFeatures', document.getElementById('featureFontSize').value)">Apply</button>
                <button onclick="insertFormatting('nodeFeatures', '[SIZE=10]', '[/SIZE]')">Small</button>
                <button onclick="insertFormatting('nodeFeatures', '[SIZE=14]', '[/SIZE]')">Normal</button>
                <button onclick="insertFormatting('nodeFeatures', '[SIZE=18]', '[/SIZE]')">Large</button>
            </div>
            <textarea id="nodeFeatures" rows="4" placeholder="Enter features, one per line&#10;e.g.&#10;~EPP~&#10;uD&#10;+past"></textarea>

            <label for="editNodeStyle">Node Style:</label>
            <select id="editNodeStyle">
                <option value="none">None (Text Only)</option>
                <option value="circle">Circle</option>
                <option value="box">Box</option>
            </select>
            <div class="modal-buttons">
                <button onclick="closeTextModal()">Cancel (Esc)</button>
                <button onclick="saveNodeProperties()">Save (Ctrl+Enter)</button>
            </div>
        </div>
    </div>

    <script>
        'use strict';
        
        // ========================================
        // CONFIGURATION MODULE
        // ========================================
        const CONFIG = Object.freeze({
            GRID_SIZE: 20,
            MAX_HISTORY_STATES: 30,
            NODE_PADDING: 10,
            LINE_HEIGHT: 20,
            FEATURE_LINE_HEIGHT: 16,
            ARROW_LENGTH: 10,
            ARROW_ANGLE: Math.PI / 7,
            CONTROL_POINT_RADIUS: 6,
            SELECTION_THRESHOLD: 10,
            MOVEMENT_SELECTION_THRESHOLD: 15,
            DEFAULT_CURVE_OFFSET: 50,
            MIN_CANVAS_WIDTH: 400,
            MIN_CANVAS_HEIGHT: 300,
            DEFAULT_CANVAS_WIDTH: 1200,
            DEFAULT_CANVAS_HEIGHT: 600,
            AUTO_FIT_PADDING: 100,
            PERFORMANCE_SAMPLE_SIZE: 60
        });

        // ========================================
        // TEXT FORMATTING MODULE
        // ========================================
        const TextFormatter = (() => {
            // Cache for parsed text to avoid recomputation
            const parseCache = new Map();
            const maxCacheSize = 100;

            // Parse formatted text into segments with style information
            function parseFormattedText(text) {
                // Check cache first
                if (parseCache.has(text)) {
                    return parseCache.get(text);
                }

                const segments = [];
                
                // Handle empty text
                if (!text || text.length === 0) {
                    return [{ text: '', styles: {} }];
                }

                // Simple regex patterns that are more reliable
                const formatPatterns = [
                    { regex: /\*\*(.*?)\*\*/g, style: 'bold', open: '**', close: '**' },
                    { regex: /\*(.*?)\*/g, style: 'italic', open: '*', close: '*' },
                    { regex: /~(.*?)~/g, style: 'strikethrough', open: '~', close: '~' },
                    { regex: /\^(.*?)\^/g, style: 'superscript', open: '^', close: '^' },
                    { regex: /_(.*?)_/g, style: 'subscript', open: '_', close: '_' },
                    { regex: /\[SC\](.*?)\[\/SC\]/gi, style: 'smallcaps', open: '[SC]', close: '[/SC]' },
                    { regex: /\[SIZE=(\d+)\](.*?)\[\/SIZE\]/gi, style: 'fontsize', open: '[SIZE=', close: '[/SIZE]' }
                ];

                // Find all formatting markers
                const markers = [];
                formatPatterns.forEach(pattern => {
                    let match;
                    const regex = new RegExp(pattern.regex.source, 'gi');
                    let iterations = 0;
                    while ((match = regex.exec(text)) !== null && iterations < 1000) {
                        // Prevent bold from matching inside italic asterisks
                        if (pattern.style === 'italic') {
                            // Skip if this is part of a bold marker
                            const beforeChar = text[match.index - 1];
                            const afterChar = text[match.index + match[0].length];
                            if (beforeChar === '*' || afterChar === '*') {
                                iterations++;
                                continue;
                            }
                        }

                        let content, contentStart, contentEnd;
                        if (pattern.style === 'fontsize') {
                            // Special handling for font size which has size value as first capture group
                            content = match[2]; // Text content is the second capture group
                            contentStart = match.index + match[0].indexOf(content);
                            contentEnd = contentStart + content.length;
                        } else {
                            content = match[1];
                            contentStart = match.index + pattern.open.length;
                            contentEnd = match.index + match[0].length - pattern.close.length;
                        }

                        const marker = {
                            start: match.index,
                            end: match.index + match[0].length,
                            contentStart: contentStart,
                            contentEnd: contentEnd,
                            style: pattern.style,
                            content: content
                        };

                        // Add font size value for fontsize style
                        if (pattern.style === 'fontsize') {
                            marker.fontSize = parseInt(match[1]);
                        }

                        markers.push(marker);
                        iterations++;
                    }
                });

                // Sort markers by position, then by length (longer patterns first)
                markers.sort((a, b) => {
                    if (a.start !== b.start) return a.start - b.start;
                    return (b.end - b.start) - (a.end - a.start);
                });

                // Remove overlapping markers (keep longer ones)
                const filteredMarkers = [];
                for (const marker of markers) {
                    const overlaps = filteredMarkers.some(existing => 
                        (marker.start >= existing.start && marker.start < existing.end) ||
                        (marker.end > existing.start && marker.end <= existing.end) ||
                        (marker.start <= existing.start && marker.end >= existing.end)
                    );
                    if (!overlaps) {
                        filteredMarkers.push(marker);
                    }
                }

                // Process text with safe loop
                let pos = 0;
                const maxIterations = text.length + 100; // Safety limit
                let iterations = 0;

                while (pos < text.length && iterations < maxIterations) {
                    iterations++;
                    
                    // Find the next marker at current position
                    const currentMarker = filteredMarkers.find(m => m.start === pos);
                    
                    if (currentMarker) {
                        // Add the formatted content
                        if (currentMarker.content && currentMarker.content.length > 0) {
                            const styles = {};
                            if (currentMarker.style === 'fontsize') {
                                styles.fontSize = currentMarker.fontSize;
                            } else {
                                styles[currentMarker.style] = true;
                            }
                            segments.push({
                                text: currentMarker.content,
                                styles: styles
                            });
                        }
                        pos = currentMarker.end;
                    } else {
                        // Find the next marker start
                        let nextMarkerStart = text.length;
                        for (const marker of filteredMarkers) {
                            if (marker.start > pos && marker.start < nextMarkerStart) {
                                nextMarkerStart = marker.start;
                            }
                        }
                        
                        // Add unformatted text
                        const unformattedText = text.substring(pos, nextMarkerStart);
                        if (unformattedText.length > 0) {
                            segments.push({
                                text: unformattedText,
                                styles: {}
                            });
                        }
                        
                        pos = nextMarkerStart;
                    }
                }

                // Fallback: if no segments were created, return the original text
                if (segments.length === 0) {
                    segments.push({
                        text: text,
                        styles: {}
                    });
                }

                // Cache the result
                if (parseCache.size >= maxCacheSize) {
                    // Clear oldest entries
                    const firstKey = parseCache.keys().next().value;
                    parseCache.delete(firstKey);
                }
                parseCache.set(text, segments);

                return segments;
            }

            // Convert segments back to formatted text (for backwards compatibility)
            function segmentsToFormattedText(segments) {
                return segments.map(segment => segment.text).join('');
            }

            return { parseFormattedText, segmentsToFormattedText };
        })();

        // ========================================
        // UTILITY FUNCTIONS MODULE
        // ========================================
        const Utils = (() => {
            const snapToGrid = (coord, gridSize, enabled) => {
                return enabled ? Math.round(coord / gridSize) * gridSize : coord;
            };

            const getCanvasCoordinates = (canvas, event) => {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
            };

            const distanceToLineSegment = (x, y, x1, y1, x2, y2) => {
                const A = x - x1;
                const B = y - y1;
                const C = x2 - x1;
                const D = y2 - y1;

                const dot = A * C + B * D;
                const lenSq = C * C + D * D;
                if (lenSq === 0) return Math.sqrt(A*A + B*B);

                let param = dot / lenSq;
                let xx, yy;

                if (param < 0) {
                    xx = x1;
                    yy = y1;
                } else if (param > 1) {
                    xx = x2;
                    yy = y2;
                } else {
                    xx = x1 + param * C;
                    yy = y1 + param * D;
                }

                const dx = x - xx;
                const dy = y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            };

            return { snapToGrid, getCanvasCoordinates, distanceToLineSegment };
        })();


        // ========================================
        // STATE MANAGER MODULE
        // ========================================
        const StateManager = (() => {
            class Manager {
                constructor() {
                    this.historyStack = [];
                }

                saveState(state) {
                    const currentState = JSON.parse(JSON.stringify(state));
                    this.historyStack.push(currentState);
                    
                    if (this.historyStack.length > CONFIG.MAX_HISTORY_STATES) {
                        this.historyStack.shift();
                    }
                }

                undo() {
                    if (this.historyStack.length > 1) {
                        this.historyStack.pop();
                        return this.historyStack[this.historyStack.length - 1];
                    }
                    return null;
                }

                canUndo() {
                    return this.historyStack.length > 1;
                }

                getLastState() {
                    return this.historyStack[this.historyStack.length - 1];
                }
            }

            return { Manager };
        })();

        // ========================================
        // NODE CLASS MODULE
        // ========================================
        const NodeModule = (() => {
            class Node {
                constructor(x, y, app) {
                    this.x = Utils.snapToGrid(x, CONFIG.GRID_SIZE, app.showGrid);
                    this.y = Utils.snapToGrid(y, CONFIG.GRID_SIZE, app.showGrid);
                    this.text = 'Node';
                    this.features = [];
                    this.id = Date.now() + Math.random().toString(36).substring(2, 9);
                    this.style = 'none';
                    
                    // Cache for bounds calculation
                    this._boundsCache = null;
                    this._boundsHash = null;
                }

                _getFontString(baseSize, styles) {
                    let fontString = "";
                    if (styles.italic) fontString += "italic ";
                    if (styles.bold) fontString += "bold ";
                    
                    let currentSize = baseSize;
                    if (styles.fontSize) {
                        currentSize = styles.fontSize;
                    } else if (styles.subscript || styles.superscript) {
                        currentSize = Math.round(baseSize * 0.75);
                    }
                    fontString += `${currentSize}px Arial`;
                    return fontString;
                }

                _getYOffset(baseSize, styles) {
                    const effectiveSize = styles.fontSize || baseSize;
                    if (styles.subscript) return effectiveSize * 0.25;
                    if (styles.superscript) return -effectiveSize * 0.35;
                    return 0;
                }

                _applyTextStyles(text, styles) {
                    if (styles.smallcaps) {
                        return text.toUpperCase();
                    }
                    return text;
                }

                _measureFormattedText(formattedText, baseSize, ctx) {
                    // Safety check for context
                    if (!ctx) {
                        // Fallback calculation if context is not available
                        return { width: formattedText.length * (baseSize * 0.6), height: baseSize };
                    }
                    
                    // Quick check for unformatted text
                    if (!formattedText.includes('*') && !formattedText.includes('~') && 
                        !formattedText.includes('^') && !formattedText.includes('_') && 
                        !formattedText.includes('[SC]') && !formattedText.includes('[SIZE=')) {
                        ctx.font = `${baseSize}px Arial`;
                        const metrics = ctx.measureText(formattedText);
                        return { width: metrics.width, height: baseSize };
                    }

                    const segments = TextFormatter.parseFormattedText(formattedText);
                    let totalWidth = 0;
                    let maxHeight = baseSize;

                    segments.forEach(segment => {
                        if (segment.text.length === 0) return;
                        
                        ctx.font = this._getFontString(baseSize, segment.styles);
                        const styledText = this._applyTextStyles(segment.text, segment.styles);
                        const metrics = ctx.measureText(styledText);
                        totalWidth += metrics.width;
                        
                        let segmentSize = baseSize;
                        if (segment.styles.fontSize) {
                            segmentSize = segment.styles.fontSize;
                        } else if (segment.styles.subscript || segment.styles.superscript) {
                            segmentSize = Math.round(baseSize * 0.75);
                        }
                        maxHeight = Math.max(maxHeight, segmentSize);
                    });

                    return { width: totalWidth, height: maxHeight };
                }

                _calculateBounds() {
                    // Safety check - ensure we have access to app context
                    if (!app || !app.ctx) {
                        // Fallback bounds calculation
                        const lines = this.text.split('\n');
                        const padding = CONFIG.NODE_PADDING;
                        const estimatedWidth = Math.max(...lines.map(line => line.length * 10)) + padding * 2;
                        const mainTextHeight = lines.length * CONFIG.LINE_HEIGHT + padding;
                        const featureHeight = this.features.length * CONFIG.FEATURE_LINE_HEIGHT;
                        const totalHeight = mainTextHeight + featureHeight;
                        
                        return {
                            left: this.x - estimatedWidth / 2,
                            right: this.x + estimatedWidth / 2,
                            top: this.y,
                            bottom: this.y + totalHeight,
                            width: estimatedWidth,
                            height: totalHeight,
                            centerY: this.y + totalHeight / 2
                        };
                    }
                    
                    const lines = this.text.split('\n');
                    const padding = CONFIG.NODE_PADDING;
                    
                    // Calculate text dimensions with formatting
                    let textMaxWidth = 0;
                    lines.forEach(line => {
                        const measurements = this._measureFormattedText(line, 16, app.ctx);
                        textMaxWidth = Math.max(textMaxWidth, measurements.width);
                    });

                    let featuresVisualHeight = 0;
                    let featureContentMaxWidth = 0;

                    if (this.features.length > 0) {
                        const spaceAboveFeatures = 5;
                        const featureBracketPaddingY = 10;
                        
                        featuresVisualHeight = spaceAboveFeatures + featureBracketPaddingY + (this.features.length * CONFIG.FEATURE_LINE_HEIGHT);
                        
                        let currentFeatureTextOnlyMaxWidth = 0;
                        this.features.forEach(feature => {
                            const measurements = this._measureFormattedText(feature, 14, app.ctx);
                            currentFeatureTextOnlyMaxWidth = Math.max(currentFeatureTextOnlyMaxWidth, measurements.width);
                        });
                        featureContentMaxWidth = Math.max(currentFeatureTextOnlyMaxWidth + 40, 60); // Match the bracket sizing
                    }

                    const nodeVisualContentWidth = Math.max(textMaxWidth, featureContentMaxWidth);
                    const width = nodeVisualContentWidth + padding * 2;
                    const mainTextHeight = lines.length * CONFIG.LINE_HEIGHT + padding;
                    const totalHeight = mainTextHeight + featuresVisualHeight;
                    
                    return {
                        left: this.x - width / 2,
                        right: this.x + width / 2,
                        top: this.y,
                        bottom: this.y + totalHeight,
                        width: width,
                        height: totalHeight,
                        centerY: this.y + totalHeight / 2
                    };
                }

                getBounds() {
                    // Include text content and features in hash for proper cache invalidation
                    const featuresStr = this.features.join('|');
                    const hash = `${this.x},${this.y},${this.text.length},${this.text.substring(0, 50)},${featuresStr.length},${this.style}`;
                    if (this._boundsHash !== hash || !this._boundsCache) {
                        this._boundsCache = this._calculateBounds();
                        this._boundsHash = hash;
                    }
                    
                    // Safety check - ensure bounds exist and are valid
                    if (!this._boundsCache || typeof this._boundsCache.top === 'undefined') {
                        this._boundsCache = this._calculateBounds();
                    }
                    
                    return this._boundsCache;
                }

                getConnectionPoint(isParent, otherNode) {
                    const bounds = this.getBounds();
                    if (isParent) {
                        return { x: this.x, y: bounds.bottom };
                    } else {
                        return { x: this.x, y: bounds.top };
                    }
                }

                _drawFormattedText(ctx, formattedText, x, y, baseSize, isSelected) {
                    // Quick check for unformatted text - use simpler rendering
                    if (!formattedText.includes('*') && !formattedText.includes('~') && 
                        !formattedText.includes('^') && !formattedText.includes('_') && 
                        !formattedText.includes('[SC]') && !formattedText.includes('[SIZE=')) {
                        
                        let font = `${baseSize}px Arial`;
                        if (isSelected) {
                            font = "bold " + font;
                        }
                        ctx.font = font;
                        ctx.textAlign = 'center';
                        ctx.fillText(formattedText, x, y);
                        ctx.textAlign = 'start'; // Reset textAlign to prevent affecting subsequent draws
                        return;
                    }

                    const segments = TextFormatter.parseFormattedText(formattedText);
                    let totalWidth = 0;

                    // Ensure textAlign is set to start for manual positioning
                    ctx.textAlign = 'start';

                    // First pass: calculate total width for centering
                    segments.forEach(segment => {
                        if (segment.text.length === 0) return;
                        ctx.font = this._getFontString(baseSize, segment.styles);
                        const styledText = this._applyTextStyles(segment.text, segment.styles);
                        totalWidth += ctx.measureText(styledText).width;
                    });

                    // Start from center minus half width
                    let currentX = x - totalWidth / 2;

                    // Second pass: draw each segment
                    segments.forEach(segment => {
                        if (segment.text.length === 0) return;
                        
                        let font = this._getFontString(baseSize, segment.styles);
                        if (isSelected && !segment.styles.bold) {
                            font = "bold " + font;
                        }
                        ctx.font = font;

                        const styledText = this._applyTextStyles(segment.text, segment.styles);
                        const yOffset = this._getYOffset(baseSize, segment.styles);
                        const actualY = y + yOffset;

                        ctx.fillText(styledText, currentX, actualY);

                        // Draw strikethrough if needed
                        if (segment.styles.strikethrough) {
                            const metrics = ctx.measureText(styledText);
                            ctx.beginPath();
                            ctx.moveTo(currentX, actualY);
                            ctx.lineTo(currentX + metrics.width, actualY);
                            ctx.strokeStyle = ctx.fillStyle;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }

                        currentX += ctx.measureText(styledText).width;
                    });
                }

                draw(ctx, isSelected, isDominanceSelected = false) {
                    const lines = this.text.split('\n');
                    const padding = CONFIG.NODE_PADDING;
                    const nodeHeight = lines.length * CONFIG.LINE_HEIGHT + padding;

                    // Apply shadow for selection
                    if (isSelected || isDominanceSelected) {
                        if (isDominanceSelected && !isSelected) {
                            // Subtler highlighting for dominated nodes
                            ctx.shadowColor = 'rgba(255, 165, 0, 0.8)'; // Orange
                            ctx.shadowBlur = 12;
                        } else {
                            // Primary selection highlighting
                            ctx.shadowColor = 'rgba(0, 123, 255, 1)';
                            ctx.shadowBlur = 15;
                        }
                    }

                    // Calculate text width for shape sizing
                    let currentTextMaxWidth = 0;
                    lines.forEach(line => {
                        const measurements = this._measureFormattedText(line, 16, ctx);
                        currentTextMaxWidth = Math.max(currentTextMaxWidth, measurements.width);
                    });
                    const currentShapeWidth = currentTextMaxWidth + padding * 2;

                    // Draw node shape
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 1;

                    if (this.style === 'circle') {
                        const radius = Math.max(currentShapeWidth, nodeHeight) / 2;
                        const centerY = this.y + nodeHeight / 2;
                        ctx.beginPath();
                        ctx.arc(this.x, centerY, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (this.style === 'box') {
                        ctx.beginPath();
                        ctx.rect(this.x - currentShapeWidth / 2, this.y, currentShapeWidth, nodeHeight);
                        ctx.stroke();
                    }

                    // Draw node text with formatting
                    ctx.fillStyle = '#333';
                    ctx.textAlign = 'start'; 
                    ctx.textBaseline = 'middle';

                    lines.forEach((line, i) => {
                        const baseTextY = this.y + padding / 2 + (i + 0.5) * CONFIG.LINE_HEIGHT;
                        this._drawFormattedText(ctx, line, this.x, baseTextY, 16, isSelected || isDominanceSelected);
                    });

                    // Draw features with formatting
                    if (this.features.length > 0) {
                        const featureY = this.y + nodeHeight;
                        
                        let currentFeatureMaxWidth = 0;
                        this.features.forEach(feature => {
                            const measurements = this._measureFormattedText(feature, 14, ctx);
                            currentFeatureMaxWidth = Math.max(currentFeatureMaxWidth, measurements.width);
                        });
                        
                        const bracketWidth = Math.max(currentFeatureMaxWidth + 10, 40);
                        const bracketHeight = this.features.length * CONFIG.FEATURE_LINE_HEIGHT + 5;
                        
                        // Draw brackets
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(this.x - bracketWidth/2, featureY);
                        ctx.lineTo(this.x - bracketWidth/2 + 5, featureY);
                        ctx.moveTo(this.x - bracketWidth/2, featureY);
                        ctx.lineTo(this.x - bracketWidth/2, featureY + bracketHeight);
                        ctx.moveTo(this.x - bracketWidth/2, featureY + bracketHeight);
                        ctx.lineTo(this.x - bracketWidth/2 + 5, featureY + bracketHeight);
                        ctx.moveTo(this.x + bracketWidth/2, featureY);
                        ctx.lineTo(this.x + bracketWidth/2 - 5, featureY);
                        ctx.moveTo(this.x + bracketWidth/2, featureY);
                        ctx.lineTo(this.x + bracketWidth/2, featureY + bracketHeight);
                        ctx.moveTo(this.x + bracketWidth/2, featureY + bracketHeight);
                        ctx.lineTo(this.x + bracketWidth/2 - 5, featureY + bracketHeight);
                        ctx.stroke();
                        
                        // Draw feature text with formatting - changed to black color
                        ctx.fillStyle = '#333'; 
                        this.features.forEach((feature, i) => {
                            const baseFeatureTextY = featureY + 5 + (i * CONFIG.FEATURE_LINE_HEIGHT) + CONFIG.FEATURE_LINE_HEIGHT / 2 - 2;
                            this._drawFormattedText(ctx, feature, this.x, baseFeatureTextY, 14, false);
                        });
                    }

                    // Reset shadow
                    if (isSelected || isDominanceSelected) {
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                    }
                }

                isPointInside(x, y) {
                    const bounds = this.getBounds();
                    return x >= bounds.left && x <= bounds.right && 
                           y >= bounds.top && y <= bounds.bottom;
                }

                getEdgeIntersectionPoint(externalX, externalY) {
                    const bounds = this.getBounds();
                    const nodeCenterX = this.x;
                    const nodeCenterY = bounds.centerY;

                    const dx = externalX - nodeCenterX;
                    const dy = externalY - nodeCenterY;

                    if (dx === 0 && dy === 0) {
                        return { x: nodeCenterX, y: bounds.top };
                    }

                    let tMin = Infinity;
                    let intersectionX = nodeCenterX;
                    let intersectionY = nodeCenterY;

                    // Check all four edges
                    const edges = [
                        { x1: bounds.left, y1: bounds.top, x2: bounds.right, y2: bounds.top }, // top
                        { x1: bounds.left, y1: bounds.bottom, x2: bounds.right, y2: bounds.bottom }, // bottom
                        { x1: bounds.left, y1: bounds.top, x2: bounds.left, y2: bounds.bottom }, // left
                        { x1: bounds.right, y1: bounds.top, x2: bounds.right, y2: bounds.bottom } // right
                    ];

                    edges.forEach(edge => {
                        if (edge.x1 === edge.x2) { // vertical edge
                            if (dx !== 0) {
                                const t = (edge.x1 - nodeCenterX) / dx;
                                if (t > 0) {
                                    const y = nodeCenterY + t * dy;
                                    if (y >= edge.y1 && y <= edge.y2 && t < tMin) {
                                        tMin = t;
                                        intersectionX = edge.x1;
                                        intersectionY = y;
                                    }
                                }
                            }
                        } else { // horizontal edge
                            if (dy !== 0) {
                                const t = (edge.y1 - nodeCenterY) / dy;
                                if (t > 0) {
                                    const x = nodeCenterX + t * dx;
                                    if (x >= edge.x1 && x <= edge.x2 && t < tMin) {
                                        tMin = t;
                                        intersectionX = x;
                                        intersectionY = edge.y1;
                                    }
                                }
                            }
                        }
                    });

                    if (tMin === Infinity) {
                        // Fallback
                        if (Math.abs(dx) > Math.abs(dy)) {
                            return dx > 0 ? { x: bounds.right, y: nodeCenterY } : { x: bounds.left, y: nodeCenterY };
                        } else {
                            return dy > 0 ? { x: nodeCenterX, y: bounds.bottom } : { x: nodeCenterX, y: bounds.top };
                        }
                    }

                    return { x: intersectionX, y: intersectionY };
                }
            }

            return { Node };
        })();

        // ========================================
        // CONNECTION CLASS MODULE
        // ========================================
        const ConnectionModule = (() => {
            class Connection {
                constructor(from, to) {
                    this.from = from;
                    this.to = to;
                    this.id = Date.now() + Math.random().toString(36).substring(2, 9);
                }

                draw(ctx, isSelected) {
                    const fromPoint = this.from.getConnectionPoint(true, this.to);
                    const toPoint = this.to.getConnectionPoint(false, this.from);

                    if (isSelected) {
                        ctx.shadowColor = 'rgba(0, 123, 255, 0.7)';
                        ctx.shadowBlur = 10;
                        ctx.strokeStyle = '#007BFF';
                        ctx.lineWidth = 3;
                    } else {
                        ctx.strokeStyle = '#666';
                        ctx.lineWidth = 2;
                    }

                    ctx.beginPath();
                    ctx.moveTo(fromPoint.x, fromPoint.y);
                    ctx.lineTo(toPoint.x, toPoint.y);
                    ctx.stroke();

                    if (isSelected) {
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';
                    }
                }

                distanceToPoint(x, y) {
                    const fromPoint = this.from.getConnectionPoint(true, this.to);
                    const toPoint = this.to.getConnectionPoint(false, this.from);
                    return Utils.distanceToLineSegment(x, y, fromPoint.x, fromPoint.y, toPoint.x, toPoint.y);
                }
            }

            return { Connection };
        })();

        // ========================================
        // MOVEMENT ARROW CLASS MODULE
        // ========================================
        const MovementArrowModule = (() => {
            class MovementArrow {
                constructor(fromNode, toNode, initialCurveDirection = 1) {
                    this.from = fromNode;
                    this.to = toNode;
                    this.id = Date.now() + Math.random().toString(36).substring(2, 11);
                    this.controlPointOffset = CONFIG.DEFAULT_CURVE_OFFSET;
                    this.curveDirection = initialCurveDirection;
                    this.controlPointHandleRadius = CONFIG.CONTROL_POINT_RADIUS;

                    const initialPoints = this._calculateInitialControlPoint();
                    this.controlPointX = initialPoints.x;
                    this.controlPointY = initialPoints.y;

                    // Cache for performance
                    this._pointsCache = null;
                    this._pointsHash = null;
                }

                _calculateInitialControlPoint(forCurveDirection = this.curveDirection) {
                    const fromNodeBounds = this.from.getBounds();
                    const toNodeBounds = this.to.getBounds();

                    const initialFromX = this.from.x;
                    const initialFromY = fromNodeBounds.centerY;
                    const initialToX = this.to.x;
                    const initialToY = toNodeBounds.centerY;
                    
                    const midX = (initialFromX + initialToX) / 2;
                    const midY = (initialFromY + initialToY) / 2;

                    let dCtrlX = initialToX - initialFromX;
                    let dCtrlY = initialToY - initialFromY;
                    const lenCtrl = Math.sqrt(dCtrlX*dCtrlX + dCtrlY*dCtrlY);

                    let perpDx, perpDy;
                    if (lenCtrl === 0) {
                        perpDx = 0;
                        perpDy = 1;
                    } else {
                        perpDx = -dCtrlY / lenCtrl;
                        perpDy = dCtrlX / lenCtrl;
                    }

                    return {
                        x: midX + perpDx * this.controlPointOffset * forCurveDirection,
                        y: midY + perpDy * this.controlPointOffset * forCurveDirection
                    };
                }

                getPoints() {
                    // Cache points calculation
                    const hash = `${this.from.x},${this.from.y},${this.to.x},${this.to.y},${this.controlPointX},${this.controlPointY}`;
                    if (this._pointsHash !== hash) {
                        const controlPoint = { x: this.controlPointX, y: this.controlPointY };
                        const fromPoint = this.from.getEdgeIntersectionPoint(this.controlPointX, this.controlPointY);
                        const toPoint = this.to.getEdgeIntersectionPoint(this.controlPointX, this.controlPointY);
                        
                        this._pointsCache = { fromPoint, toPoint, controlPoint };
                        this._pointsHash = hash;
                    }
                    return this._pointsCache;
                }

                draw(ctx, isSelected) {
                    const { fromPoint, toPoint, controlPoint } = this.getPoints();

                    ctx.beginPath();
                    ctx.moveTo(fromPoint.x, fromPoint.y);
                    ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, toPoint.x, toPoint.y);

                    if (isSelected) {
                        ctx.strokeStyle = 'rgba(255, 100, 0, 0.9)';
                        ctx.lineWidth = 2.5;
                        ctx.shadowColor = 'rgba(255, 100, 0, 0.7)';
                        ctx.shadowBlur = 8;
                    } else {
                        ctx.strokeStyle = 'rgba(50, 50, 200, 0.8)';
                        ctx.lineWidth = 1.5;
                    }
                    
                    ctx.setLineDash([5, 5]);
                    ctx.stroke();
                    ctx.setLineDash([]);

                    // Draw arrowhead
                    const angle = Math.atan2(toPoint.y - controlPoint.y, toPoint.x - controlPoint.x);

                    ctx.beginPath();
                    ctx.moveTo(toPoint.x, toPoint.y);
                    ctx.lineTo(toPoint.x - CONFIG.ARROW_LENGTH * Math.cos(angle - CONFIG.ARROW_ANGLE), 
                              toPoint.y - CONFIG.ARROW_LENGTH * Math.sin(angle - CONFIG.ARROW_ANGLE));
                    ctx.moveTo(toPoint.x, toPoint.y);
                    ctx.lineTo(toPoint.x - CONFIG.ARROW_LENGTH * Math.cos(angle + CONFIG.ARROW_ANGLE), 
                              toPoint.y - CONFIG.ARROW_LENGTH * Math.sin(angle + CONFIG.ARROW_ANGLE));
                    ctx.stroke();

                    if (isSelected) {
                        ctx.shadowBlur = 0;
                        ctx.shadowColor = 'transparent';

                        // Draw control point handle
                        ctx.beginPath();
                        ctx.arc(this.controlPointX, this.controlPointY, this.controlPointHandleRadius, 0, Math.PI * 2);
                        ctx.fillStyle = 'rgba(0, 123, 255, 0.7)';
                        ctx.fill();
                        ctx.strokeStyle = 'rgba(0, 80, 180, 1)';
                        ctx.lineWidth = 1;
                        ctx.stroke();
                    }
                }

                distanceToPoint(x, y) {
                    const { fromPoint, toPoint, controlPoint } = this.getPoints();
                    const numSegments = 20;
                    let minDistance = Infinity;

                    for (let i = 0; i <= numSegments; i++) {
                        const t = i / numSegments;
                        const curveX = Math.pow(1 - t, 2) * fromPoint.x + 2 * (1 - t) * t * controlPoint.x + Math.pow(t, 2) * toPoint.x;
                        const curveY = Math.pow(1 - t, 2) * fromPoint.y + 2 * (1 - t) * t * controlPoint.y + Math.pow(t, 2) * toPoint.y;

                        const distance = Math.sqrt(Math.pow(x - curveX, 2) + Math.pow(y - curveY, 2));
                        minDistance = Math.min(minDistance, distance);
                    }
                    return minDistance;
                }

                isControlPointHit(x, y) {
                    const dx = x - this.controlPointX;
                    const dy = y - this.controlPointY;
                    return Math.sqrt(dx * dx + dy * dy) < this.controlPointHandleRadius + 3;
                }
            }

            return { MovementArrow };
        })();

        // ========================================
        // DOMINANCE SELECTION MODULE
        // ========================================
        const DominanceModule = (() => {
            
            // Find all nodes dominated by a given root node
            function findDominatedNodes(rootNode, allConnections) {
                // Safety checks
                if (!rootNode || !allConnections) {
                    return new Set();
                }
                
                const dominatedNodes = new Set();
                const toProcess = [rootNode];
                
                // Add the root node itself
                dominatedNodes.add(rootNode);
                
                // Safety counter to prevent infinite loops
                let iterations = 0;
                const maxIterations = 1000;
                
                while (toProcess.length > 0 && iterations < maxIterations) {
                    iterations++;
                    const currentNode = toProcess.shift();
                    
                    // Find all connections where current node is the parent (from)
                    const childConnections = allConnections.filter(conn => 
                        conn && conn.from === currentNode && conn.to
                    );
                    
                    for (const connection of childConnections) {
                        const childNode = connection.to;
                        
                        // If we haven't seen this child before, add it to dominated set and queue for processing
                        if (!dominatedNodes.has(childNode)) {
                            dominatedNodes.add(childNode);
                            toProcess.push(childNode);
                        }
                    }
                }
                
                return dominatedNodes;
            }
            
            return { findDominatedNodes };
        })();

        // ========================================
        // MAIN APPLICATION CLASS
        // ========================================
        class SyntacticTreeApp {
            constructor() {
                // Initialize modules                
                this.stateManager = new StateManager.Manager();
                
                // Get canvas and context
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Application state
                this.mode = 'add';
                this.nodes = [];
                this.connections = [];
                this.movementArrows = [];
                this.selectedNode = null;
                this.selectedConnection = null;
                this.selectedMovementArrow = null;
                
                // NEW: Dominance selection state
                this.dominanceSelectedNodes = new Set(); // Set of nodes in dominance selection
                
                this.connectingFrom = null;
                this.connectingMovementFrom = null;
                this.editingNode = null;
                
                // Interaction state
                this.isDragging = false;
                this.draggingControlPointArrow = null;
                this.dragOffset = { x: 0, y: 0 };
                this._dragRedrawPending = false;
                
                // Settings
                this.showGrid = true;
                this.canvasWidth = CONFIG.DEFAULT_CANVAS_WIDTH;
                this.canvasHeight = CONFIG.DEFAULT_CANVAS_HEIGHT;
                
                this.initializeEventListeners();
                this.initializeCanvasSize();
                this.resizeCanvas();
                this.saveState();
                this.setMode('add');
                this.redraw();
            }

            // ========================================
            // UTILITY METHODS
            // ========================================
            snapToGridCoord(coord) {
                return Utils.snapToGrid(coord, CONFIG.GRID_SIZE, this.showGrid);
            }

            getCanvasCoordinates(e) {
                return Utils.getCanvasCoordinates(this.canvas, e);
            }

            initializeCanvasSize() {
                const widthInput = document.getElementById('canvasWidth');
                const heightInput = document.getElementById('canvasHeight');
                
                widthInput.value = this.canvasWidth;
                heightInput.value = this.canvasHeight;
            }

            resizeCanvas() {
                // Set canvas internal resolution to match our desired size
                this.canvas.width = this.canvasWidth;
                this.canvas.height = this.canvasHeight;
                
                // Set CSS size to match internal resolution (prevents scaling)
                this.canvas.style.width = this.canvasWidth + 'px';
                this.canvas.style.height = this.canvasHeight + 'px';
                
                this.redraw();
            }

            updateCanvasSize() {
                const widthInput = document.getElementById('canvasWidth');
                const heightInput = document.getElementById('canvasHeight');
                
                const newWidth = Math.max(CONFIG.MIN_CANVAS_WIDTH, parseInt(widthInput.value) || CONFIG.DEFAULT_CANVAS_WIDTH);
                const newHeight = Math.max(CONFIG.MIN_CANVAS_HEIGHT, parseInt(heightInput.value) || CONFIG.DEFAULT_CANVAS_HEIGHT);
                
                // Update input values to reflect any corrections
                widthInput.value = newWidth;
                heightInput.value = newHeight;
                
                this.canvasWidth = newWidth;
                this.canvasHeight = newHeight;
                
                this.resizeCanvas();
            }

            autoFitCanvas() {
                if (this.nodes.length === 0) {
                    // If no nodes, use default size
                    this.canvasWidth = CONFIG.DEFAULT_CANVAS_WIDTH;
                    this.canvasHeight = CONFIG.DEFAULT_CANVAS_HEIGHT;
                } else {
                    // Calculate bounding box of all content
                    let minX = Infinity, maxX = -Infinity;
                    let minY = Infinity, maxY = -Infinity;
                    
                    // Check all nodes
                    this.nodes.forEach(node => {
                        const bounds = node.getBounds();
                        minX = Math.min(minX, bounds.left);
                        maxX = Math.max(maxX, bounds.right);
                        minY = Math.min(minY, bounds.top);
                        maxY = Math.max(maxY, bounds.bottom);
                    });
                    
                    // Check movement arrow control points
                    this.movementArrows.forEach(arrow => {
                        minX = Math.min(minX, arrow.controlPointX - 20);
                        maxX = Math.max(maxX, arrow.controlPointX + 20);
                        minY = Math.min(minY, arrow.controlPointY - 20);
                        maxY = Math.max(maxY, arrow.controlPointY + 20);
                    });
                    
                    // Add padding
                    const contentWidth = maxX - minX + CONFIG.AUTO_FIT_PADDING * 2;
                    const contentHeight = maxY - minY + CONFIG.AUTO_FIT_PADDING * 2;
                    
                    // Ensure minimum size
                    this.canvasWidth = Math.max(CONFIG.MIN_CANVAS_WIDTH, Math.ceil(contentWidth / 50) * 50);
                    this.canvasHeight = Math.max(CONFIG.MIN_CANVAS_HEIGHT, Math.ceil(contentHeight / 50) * 50);
                    
                    // If content is offset, we might need to adjust node positions
                    if (minX < CONFIG.AUTO_FIT_PADDING) {
                        const offsetX = CONFIG.AUTO_FIT_PADDING - minX;
                        this.nodes.forEach(node => {
                            node.x += offsetX;
                            node._boundsCache = null; // Invalidate cache
                        });
                        this.movementArrows.forEach(arrow => {
                            arrow.controlPointX += offsetX;
                            arrow._pointsCache = null; // Invalidate cache
                        });
                    }
                    
                    if (minY < CONFIG.AUTO_FIT_PADDING) {
                        const offsetY = CONFIG.AUTO_FIT_PADDING - minY;
                        this.nodes.forEach(node => {
                            node.y += offsetY;
                            node._boundsCache = null; // Invalidate cache
                        });
                        this.movementArrows.forEach(arrow => {
                            arrow.controlPointY += offsetY;
                            arrow._pointsCache = null; // Invalidate cache
                        });
                    }
                }
                
                // Update the input fields
                this.initializeCanvasSize();
                
                this.resizeCanvas();
                this.saveState();
            }

            // ========================================
            // NODE + DESCENDENTS SELECTION
            // ========================================
            
            selectDominanceSubtree(rootNode) {
                // Safety check
                if (!rootNode || !this.connections) {
                    return;
                }
                
                // Clear previous selection
                this.clearSelection();
                
                // Find all dominated nodes
                this.dominanceSelectedNodes = DominanceModule.findDominatedNodes(rootNode, this.connections);
                
                // Set the root as the primary selected node
                this.selectedNode = rootNode;
                
                this.redraw();
            }
            
            clearSelection() {
                this.selectedNode = null;
                this.selectedConnection = null;
                this.selectedMovementArrow = null;
                this.dominanceSelectedNodes.clear();
            }
            
            hasDominanceSelection() {
                return this.dominanceSelectedNodes.size > 0;
            }

            // ========================================
            // STATE MANAGEMENT METHODS
            // ========================================
            getCurrentStateObject() {
                return {
                    nodes: this.nodes.map(node => ({
                        x: node.x,
                        y: node.y,
                        text: node.text,
                        features: [...node.features],
                        id: node.id,
                        style: node.style
                    })),
                    connections: this.connections.map(conn => ({
                        fromId: conn.from.id,
                        toId: conn.to.id,
                        id: conn.id
                    })),
                    movementArrows: this.movementArrows.map(arrow => ({
                        fromId: arrow.from.id,
                        toId: arrow.to.id,
                        id: arrow.id,
                        curveDirection: arrow.curveDirection,
                        controlPointX: arrow.controlPointX,
                        controlPointY: arrow.controlPointY
                    })),
                    settings: {
                        showGrid: this.showGrid,
                        canvasWidth: this.canvasWidth,
                        canvasHeight: this.canvasHeight
                    }
                };
            }

            saveState() {
                const currentState = this.getCurrentStateObject();
                this.stateManager.saveState(currentState);
                this.updateUndoButtonState();
            }

            restoreState(stateToRestore) {
                if (!stateToRestore) return;

                // Restore nodes
                this.nodes = stateToRestore.nodes.map(nData => {
                    const node = new NodeModule.Node(nData.x, nData.y, this);
                    Object.assign(node, nData);
                    // Invalidate cache to ensure fresh bounds calculation
                    node._boundsCache = null;
                    node._boundsHash = null;
                    return node;
                });

                // Restore connections
                this.connections = stateToRestore.connections.map(cData => {
                    const fromNode = this.nodes.find(n => n.id === cData.fromId);
                    const toNode = this.nodes.find(n => n.id === cData.toId);
                    if (fromNode && toNode) {
                        const conn = new ConnectionModule.Connection(fromNode, toNode);
                        conn.id = cData.id;
                        return conn;
                    }
                    return null;
                }).filter(c => c !== null);

                // Restore movement arrows
                this.movementArrows = (stateToRestore.movementArrows || []).map(aData => {
                    const fromNode = this.nodes.find(n => n.id === aData.fromId);
                    const toNode = this.nodes.find(n => n.id === aData.toId);
                    if (fromNode && toNode) {
                        const arrow = new MovementArrowModule.MovementArrow(fromNode, toNode);
                        Object.assign(arrow, aData);
                        return arrow;
                    }
                    return null;
                }).filter(a => a !== null);

                // Restore settings
                if (stateToRestore.settings) {
                    this.showGrid = stateToRestore.settings.showGrid;
                    document.getElementById('gridCheckbox').checked = this.showGrid;
                    
                    if (stateToRestore.settings.canvasWidth) {
                        this.canvasWidth = stateToRestore.settings.canvasWidth;
                    }
                    if (stateToRestore.settings.canvasHeight) {
                        this.canvasHeight = stateToRestore.settings.canvasHeight;
                    }
                    this.initializeCanvasSize();
                    this.resizeCanvas();
                }

                // Reset selection state
                this.clearSelection();
                this.connectingFrom = null;
                this.connectingMovementFrom = null;
                this.draggingControlPointArrow = null;
                
                this.redraw();
            }

            undo() {
                const prevState = this.stateManager.undo();
                if (prevState) {
                    this.restoreState(prevState);
                }
                this.updateUndoButtonState();
            }

            updateUndoButtonState() {
                const undoBtn = document.getElementById('undoBtn');
                if (undoBtn) {
                    undoBtn.disabled = !this.stateManager.canUndo();
                }
            }

            // ========================================
            // MODE MANAGEMENT METHODS
            // ========================================
            setMode(newMode) {
                this.mode = newMode;
                
                // Reset mode-specific state
                this.connectingFrom = null;
                this.connectingMovementFrom = null;
                
                // Update toolbar button states
                document.querySelectorAll('.toolbar button').forEach(btn => {
                    if (['addNodeBtn', 'connectBtn', 'selectBtn', 'addMovementBtn'].includes(btn.id)) {
                        btn.classList.remove('active');
                    }
                });
                
                // Set active button and cursor
                const modeConfig = {
                    'add': { btnId: 'addNodeBtn', cursor: 'crosshair' },
                    'connect': { btnId: 'connectBtn', cursor: 'pointer' },
                    'select': { btnId: 'selectBtn', cursor: 'move' },
                    'addMovement': { btnId: 'addMovementBtn', cursor: 'pointer' }
                };
                
                const config = modeConfig[newMode];
                if (config) {
                    document.getElementById(config.btnId).classList.add('active');
                    this.canvas.style.cursor = config.cursor;
                }
                
                this.redraw();
            }

            // ========================================
            // EVENT HANDLING METHODS
            // ========================================
            initializeEventListeners() {
                // Toolbar buttons
                document.getElementById('addNodeBtn').addEventListener('click', () => this.setMode('add'));
                document.getElementById('connectBtn').addEventListener('click', () => this.setMode('connect'));
                document.getElementById('selectBtn').addEventListener('click', () => this.setMode('select'));
                document.getElementById('addMovementBtn').addEventListener('click', () => this.setMode('addMovement'));
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('deleteBtn').addEventListener('click', () => this.deleteSelected());
                
                // Clear button with extra verification
                const clearBtn = document.getElementById('clearBtn');
                if (clearBtn) {
                    clearBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        console.log('Clear button clicked');
                        this.clearAll();
                    });
                    console.log('Clear button event listener attached');
                } else {
                    console.error('Clear button not found');
                }
                
                document.getElementById('exportBtn').addEventListener('click', () => this.exportCanvas());
                document.getElementById('saveTreeBtn').addEventListener('click', () => this.saveTreeToFile());
                document.getElementById('loadTreeBtn').addEventListener('click', () => document.getElementById('loadTreeInput').click());                

                // Grid checkbox
                document.getElementById('gridCheckbox').addEventListener('change', (e) => {
                    this.showGrid = e.target.checked;
                    this.saveState();
                    this.redraw();
                });

                // Canvas size controls
                document.getElementById('canvasWidth').addEventListener('input', () => this.updateCanvasSize());
                document.getElementById('canvasHeight').addEventListener('input', () => this.updateCanvasSize());
                document.getElementById('autoFitBtn').addEventListener('click', () => this.autoFitCanvas());

                // File input
                document.getElementById('loadTreeInput').addEventListener('change', (e) => this.loadTreeFromFile(e));

                // Canvas events
                this.canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.canvas.addEventListener('dblclick', (e) => this.handleCanvasDoubleClick(e));
                this.canvas.addEventListener('mousedown', (e) => this.handleCanvasMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleCanvasMouseMove(e));
                this.canvas.addEventListener('mouseup', () => this.handleCanvasMouseUp());
                this.canvas.addEventListener('mouseleave', () => this.handleCanvasMouseLeave());

                // Keyboard events
                document.addEventListener('keydown', (e) => this.handleKeyDown(e));

                // Note: Removed automatic window resize since we now have manual canvas size controls
            }

            handleCanvasClick(e) {
                const { x, y } = this.getCanvasCoordinates(e);
                
                switch (this.mode) {
                    case 'add':
                        this.handleAddNode(x, y);
                        break;
                    case 'connect':
                        this.handleConnect(x, y);
                        break;
                    case 'addMovement':
                        this.handleAddMovement(x, y);
                        break;
                    case 'select':
                        this.handleSelect(x, y, e.ctrlKey || e.metaKey); // Pass modifier key state
                        break;
                }
                
                this.redraw();
            }

            handleAddNode(x, y) {
                const node = new NodeModule.Node(x, y, this);
                this.nodes.push(node);
                this.editingNode = node;
                this.editingNode._isNewNodePendingConfirmation = true;
                this.openPropertiesModal();
            }

            handleConnect(x, y) {
                const clickedNode = this.nodes.find(n => n.isPointInside(x, y));
                if (clickedNode) {
                    if (!this.connectingFrom) {
                        this.connectingFrom = clickedNode;
                        this.selectedNode = clickedNode;
                        this.selectedConnection = null;
                        this.clearSelection(); // Clear dominance selection
                    } else if (clickedNode !== this.connectingFrom) {
                        const existingConnection = this.connections.find(c =>
                            (c.from === this.connectingFrom && c.to === clickedNode) ||
                            (c.from === clickedNode && c.to === this.connectingFrom)
                        );
                        if (!existingConnection) {
                            this.connections.push(new ConnectionModule.Connection(this.connectingFrom, clickedNode));
                            this.saveState();
                        }
                        this.connectingFrom = null;
                        this.clearSelection();
                    }
                } else {
                    this.connectingFrom = null;
                    this.clearSelection();
                }
            }

            handleAddMovement(x, y) {
                const clickedNode = this.nodes.find(n => n.isPointInside(x, y));
                if (clickedNode) {
                    if (!this.connectingMovementFrom) {
                        this.connectingMovementFrom = clickedNode;
                        this.selectedNode = clickedNode;
                        this.selectedConnection = null;
                        this.selectedMovementArrow = null;
                        this.clearSelection(); // Clear dominance selection
                    } else if (clickedNode !== this.connectingMovementFrom) {
                        const fromCenter = { 
                            x: this.connectingMovementFrom.x, 
                            y: this.connectingMovementFrom.getBounds().centerY 
                        };
                        const toCenter = { 
                            x: clickedNode.x, 
                            y: clickedNode.getBounds().centerY 
                        };
                        
                        const sideValue = (toCenter.x - fromCenter.x) * (y - fromCenter.y) - 
                                          (toCenter.y - fromCenter.y) * (x - fromCenter.x);
                        
                        const initialCurveDir = (sideValue >= 0) ? 1 : -1;
                        
                        this.movementArrows.push(new MovementArrowModule.MovementArrow(this.connectingMovementFrom, clickedNode, initialCurveDir));
                        this.saveState();
                        this.connectingMovementFrom = null;
                        this.clearSelection();
                    }
                } else {
                    this.connectingMovementFrom = null;
                    this.clearSelection();
                }
            }

            handleSelect(x, y, isDominanceModifier) {
                const clickedNode = this.nodes.find(n => n.isPointInside(x, y));
                
                // NEW: Handle dominance selection with Ctrl+click
                if (clickedNode && isDominanceModifier) {
                    this.selectDominanceSubtree(clickedNode);
                    return;
                }
                
                // Regular selection logic
                this.clearSelection();
                this.selectedNode = clickedNode || null;
                
                if (!this.selectedNode) {
                    this.selectedMovementArrow = this.movementArrows.find(a => 
                        a.distanceToPoint(x, y) < CONFIG.MOVEMENT_SELECTION_THRESHOLD) || null;
                    
                    if (!this.selectedMovementArrow) {
                        this.selectedConnection = this.connections.find(c => 
                            c.distanceToPoint(x, y) < CONFIG.SELECTION_THRESHOLD) || null;
                    }
                }
            }

            handleCanvasDoubleClick(e) {
                const { x, y } = this.getCanvasCoordinates(e);
                const clickedNode = this.nodes.find(n => n.isPointInside(x, y));
                
                if (clickedNode) {
                    this.editingNode = clickedNode;
                    this.openPropertiesModal();
                }
            }

            handleCanvasMouseDown(e) {
                if (this.mode !== 'select') return;
                
                const { x, y } = this.getCanvasCoordinates(e);
                
                // Check for control point drag first
                if (this.selectedMovementArrow && this.selectedMovementArrow.isControlPointHit(x, y)) {
                    this.draggingControlPointArrow = this.selectedMovementArrow;
                    this.isDragging = false;
                    this.clearSelection();
                    this.canvas.style.cursor = 'crosshair';
                    return;
                }
                
                // Check for node selection and dragging
                this.selectedNode = this.nodes.find(n => n.isPointInside(x, y)) || null;
                
                if (this.selectedNode) {
                    this.isDragging = true;
                    this.dragOffset.x = x - this.selectedNode.x;
                    this.dragOffset.y = y - this.selectedNode.y;
                    this.selectedConnection = null;
                    this.selectedMovementArrow = null;
                    this.canvas.style.cursor = 'grabbing';
                } else {
                    // Check for connection or movement arrow selection
                    this.selectedConnection = this.connections.find(c => 
                        c.distanceToPoint(x, y) < CONFIG.SELECTION_THRESHOLD) || null;
                    
                    if (!this.selectedConnection) {
                        this.selectedMovementArrow = this.movementArrows.find(a => 
                            a.distanceToPoint(x, y) < CONFIG.MOVEMENT_SELECTION_THRESHOLD) || null;
                    }
                }
                
                this.redraw();
            }

            handleCanvasMouseMove(e) {
                const { x, y } = this.getCanvasCoordinates(e);
                
                if (this.isDragging && this.selectedNode) {
                    const newX = x - this.dragOffset.x;
                    const newY = y - this.dragOffset.y;
                    
                    // NEW: If we have dominance selection, move all nodes together
                    if (this.hasDominanceSelection()) {
                        const deltaX = this.snapToGridCoord(newX) - this.selectedNode.x;
                        const deltaY = this.snapToGridCoord(newY) - this.selectedNode.y;
                        
                        // Move all dominated nodes by the same offset
                        for (const node of this.dominanceSelectedNodes) {
                            node.x += deltaX;
                            node.y += deltaY;
                            node._boundsCache = null; // Invalidate cache
                        }
                    } else {
                        // Regular single node movement
                        this.selectedNode.x = this.snapToGridCoord(newX);
                        this.selectedNode.y = this.snapToGridCoord(newY);
                    }
                    
                    // Throttle redraws during dragging
                    if (!this._dragRedrawPending) {
                        this._dragRedrawPending = true;
                        requestAnimationFrame(() => {
                            this.redraw();
                            this._dragRedrawPending = false;
                        });
                    }
                } else if (this.draggingControlPointArrow) {
                    this.draggingControlPointArrow.controlPointX = x;
                    this.draggingControlPointArrow.controlPointY = y;
                    
                    // Throttle redraws during control point dragging
                    if (!this._dragRedrawPending) {
                        this._dragRedrawPending = true;
                        requestAnimationFrame(() => {
                            this.redraw();
                            this._dragRedrawPending = false;
                        });
                    }
                } else if (this.mode === 'select' && !this.isDragging) {
                    this.updateCursor(x, y);
                }
            }

            updateCursor(x, y) {
                const isOverNode = this.nodes.some(n => n.isPointInside(x, y));
                const isOverConnection = this.connections.some(c => c.distanceToPoint(x, y) < CONFIG.SELECTION_THRESHOLD);
                const isOverMovementArrow = this.movementArrows.some(a => a.distanceToPoint(x, y) < CONFIG.MOVEMENT_SELECTION_THRESHOLD);
                const isOverControlPoint = this.selectedMovementArrow && this.selectedMovementArrow.isControlPointHit(x, y);
                
                if (isOverControlPoint) {
                    this.canvas.style.cursor = 'crosshair';
                } else if (isOverNode || isOverConnection || isOverMovementArrow) {
                    this.canvas.style.cursor = 'grab';
                } else {
                    this.canvas.style.cursor = 'move';
                }
            }

            handleCanvasMouseUp() {
                if (this.isDragging && this.selectedNode) {
                    this.saveState();
                }
                if (this.draggingControlPointArrow) {
                    this.saveState();
                    this.draggingControlPointArrow = null;
                }
                this.isDragging = false;
                if (this.mode === 'select') {
                    this.canvas.style.cursor = 'move';
                }
            }

            handleCanvasMouseLeave() {
                if (this.mode === 'select') {
                    this.canvas.style.cursor = 'move';
                }
            }

            handleKeyDown(e) {
                const isModalActive = document.getElementById('textModal').style.display === 'flex';
                
                if (isModalActive) {
                    if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) {
                        this.saveNodeProperties();
                        e.preventDefault();
                    } else if (e.key === 'Escape') {
                        this.closeTextModal();
                        e.preventDefault();
                    }
                    return;
                }

                switch (e.key) {
                    case 'Delete':
                    case 'Backspace':
                        if (this.selectedNode || this.selectedConnection || this.selectedMovementArrow || this.hasDominanceSelection()) {
                            this.deleteSelected();
                            e.preventDefault();
                        }
                        break;
                        
                    case 'z':
                        if (e.ctrlKey || e.metaKey) {
                            this.undo();
                            e.preventDefault();
                        }
                        break;
                        
                    case 'Escape':
                        this.handleEscape();
                        e.preventDefault();
                        break;
                }
            }

            handleEscape() {
                if (this.connectingFrom) {
                    this.connectingFrom = null;
                    this.selectedNode = null;
                    this.redraw();
                } else if (this.connectingMovementFrom) {
                    this.connectingMovementFrom = null;
                    this.selectedNode = null;
                    this.redraw();
                } else if (this.selectedNode || this.selectedConnection || this.selectedMovementArrow || this.hasDominanceSelection()) {
                    this.clearSelection();
                    this.redraw();
                }
            }

            // ========================================
            // ACTION METHODS
            // ========================================
            deleteSelected() {
                let changed = false;
                
                // Handle subtree selection deletion
                if (this.hasDominanceSelection()) {
                    const nodesToDelete = Array.from(this.dominanceSelectedNodes);
                    
                    // Remove all dominated nodes
                    this.nodes = this.nodes.filter(n => !this.dominanceSelectedNodes.has(n));
                    
                    // Remove connections involving any of the deleted nodes
                    this.connections = this.connections.filter(c => 
                        !this.dominanceSelectedNodes.has(c.from) && !this.dominanceSelectedNodes.has(c.to)
                    );
                    
                    // Remove movement arrows involving any of the deleted nodes
                    this.movementArrows = this.movementArrows.filter(a => 
                        !this.dominanceSelectedNodes.has(a.from) && !this.dominanceSelectedNodes.has(a.to)
                    );
                    
                    this.clearSelection();
                    changed = true;
                } else if (this.selectedNode) {
                    this.nodes = this.nodes.filter(n => n !== this.selectedNode);
                    this.connections = this.connections.filter(c => c.from !== this.selectedNode && c.to !== this.selectedNode);
                    this.movementArrows = this.movementArrows.filter(a => a.from !== this.selectedNode && a.to !== this.selectedNode);
                    this.selectedNode = null;
                    changed = true;
                } else if (this.selectedConnection) {
                    this.connections = this.connections.filter(c => c !== this.selectedConnection);
                    this.selectedConnection = null;
                    changed = true;
                } else if (this.selectedMovementArrow) {
                    this.movementArrows = this.movementArrows.filter(a => a !== this.selectedMovementArrow);
                    this.selectedMovementArrow = null;
                    changed = true;
                }
                
                if (changed) {
                    this.saveState();
                    this.redraw();
                }
            }

            clearAll() {
                try {
                    if (!confirm('Are you sure you want to clear all nodes and connections?')) {
                        return;
                    }
                    
                    // Clear all data
                    this.nodes = [];
                    this.connections = [];
                    this.movementArrows = [];
                    
                    // Reset all selection and interaction state
                    this.clearSelection();
                    this.connectingFrom = null;
                    this.connectingMovementFrom = null;
                    this.draggingControlPointArrow = null;
                    this.editingNode = null;
                    this.isDragging = false;
                    
                    // Close any open modal
                    const modal = document.getElementById('textModal');
                    if (modal) {
                        modal.style.display = 'none';
                    }
                    
                    // Save state and redraw
                    this.saveState();
                    this.redraw();
                    
                    console.log('Canvas cleared successfully');
                } catch (error) {
                    console.error('Error clearing canvas:', error);
                    alert('Error clearing canvas. Please refresh the page.');
                }
            }

            // ========================================
            // RENDERING METHODS
            // ========================================
            drawGrid() {
                if (!this.showGrid) return;
                
                this.ctx.strokeStyle = '#e0e0e0';
                this.ctx.lineWidth = 0.5;
                
                for (let x = 0; x <= this.canvas.width; x += CONFIG.GRID_SIZE) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, 0);
                    this.ctx.lineTo(x, this.canvas.height);
                    this.ctx.stroke();
                }
                
                for (let y = 0; y <= this.canvas.height; y += CONFIG.GRID_SIZE) {
                    this.ctx.beginPath();
                    this.ctx.moveTo(0, y);
                    this.ctx.lineTo(this.canvas.width, y);
                    this.ctx.stroke();
                }
            }

            redraw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawGrid();
                
                // Draw connections first (behind everything)
                this.connections.forEach(conn => conn.draw(this.ctx, this.selectedConnection === conn));
                
                // Draw movement arrows
                this.movementArrows.forEach(arrow => arrow.draw(this.ctx, this.selectedMovementArrow === arrow));
                
                // Draw nodes last (on top) with enhanced selection rendering
                this.nodes.forEach(node => {
                    const isSelected = this.selectedNode === node;
                    const isDominanceSelected = this.dominanceSelectedNodes.has(node);
                    node.draw(this.ctx, isSelected, isDominanceSelected);
                });
            }

            // ========================================
            // FILE OPERATIONS
            // ========================================
            exportCanvas() {
                // Temporarily disable effects for clean export
                const tempStates = {
                    selectedNode: this.selectedNode,
                    selectedConnection: this.selectedConnection,
                    selectedMovementArrow: this.selectedMovementArrow,
                    draggingControlPointArrow: this.draggingControlPointArrow,
                    dominanceSelectedNodes: new Set(this.dominanceSelectedNodes),
                    showGrid: this.showGrid
                };

                this.clearSelection();
                this.draggingControlPointArrow = null;
                this.showGrid = false;

                // White background for export
                this.ctx.fillStyle = 'white';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.connections.forEach(conn => conn.draw(this.ctx, false));
                this.movementArrows.forEach(arrow => arrow.draw(this.ctx, false));
                this.nodes.forEach(node => node.draw(this.ctx, false));

                const link = document.createElement('a');
                link.download = 'syntactic-tree.png';
                link.href = this.canvas.toDataURL('image/png');
                link.click();

                // Restore states
                this.selectedNode = tempStates.selectedNode;
                this.selectedConnection = tempStates.selectedConnection;
                this.selectedMovementArrow = tempStates.selectedMovementArrow;
                this.draggingControlPointArrow = tempStates.draggingControlPointArrow;
                this.dominanceSelectedNodes = tempStates.dominanceSelectedNodes;
                this.showGrid = tempStates.showGrid;
                this.redraw();
            }

            saveTreeToFile() {
                const treeData = this.getCurrentStateObject();
                const jsonString = JSON.stringify(treeData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = 'syntactic-tree-save.json';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
            }

            loadTreeFromFile(event) {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const loadedData = JSON.parse(e.target.result);
                        if (loadedData && loadedData.nodes && loadedData.connections) {
                            this.nodes = [];
                            this.connections = [];
                            this.movementArrows = [];
                            
                            this.restoreState(loadedData);
                            
                            this.stateManager.historyStack = [];
                            this.saveState();
                            this.updateUndoButtonState();
                            this.redraw();
                        } else {
                            alert('Invalid tree file format.');
                        }
                    } catch (error) {
                        console.error("Error loading tree:", error);
                        alert('Error loading tree file. Make sure it is a valid JSON file.');
                    } finally {
                        event.target.value = null;
                    }
                };
                reader.readAsText(file);
            }

            // ========================================
            // MODAL MANAGEMENT METHODS
            // ========================================
            openPropertiesModal() {
                if (!this.editingNode) return;
                
                const modal = document.getElementById('textModal');
                modal.style.display = 'flex';
                
                document.getElementById('nodeText').value = this.editingNode.text;
                document.getElementById('nodeFeatures').value = this.editingNode.features.join('\n');
                document.getElementById('editNodeStyle').value = this.editingNode.style || 'none';

                document.getElementById('nodeText').focus();
                document.getElementById('nodeText').select();
            }

            closeTextModal() {
                document.getElementById('textModal').style.display = 'none';
                
                if (this.editingNode && this.editingNode._isNewNodePendingConfirmation) {
                    this.nodes = this.nodes.filter(n => n !== this.editingNode);
                    this.redraw();
                }
                
                this.editingNode = null;
            }

            saveNodeProperties() {
                if (!this.editingNode) return;
                
                const wasNewNode = this.editingNode._isNewNodePendingConfirmation;
                delete this.editingNode._isNewNodePendingConfirmation;

                const newText = document.getElementById('nodeText').value;
                const newFeaturesText = document.getElementById('nodeFeatures').value;
                const newStyle = document.getElementById('editNodeStyle').value;

                // Capture old values for comparison
                const oldValues = {
                    text: this.editingNode.text,
                    features: this.editingNode.features.join('\n'),
                    style: this.editingNode.style
                };

                // Apply new values
                this.editingNode.text = newText || 'Node';
                this.editingNode.features = newFeaturesText ? newFeaturesText.split('\n').filter(f => f.trim()) : [];
                this.editingNode.style = newStyle;

                // Check if anything changed
                const newValues = {
                    text: this.editingNode.text,
                    features: this.editingNode.features.join('\n'),
                    style: this.editingNode.style
                };

                const hasChanges = Object.keys(oldValues).some(key => oldValues[key] !== newValues[key]);
                
                if (wasNewNode || hasChanges) {
                    this.saveState();
                }
                
                this.redraw();
                this.closeTextModal();
            }
        }

        // ========================================
        // GLOBAL MODAL FUNCTIONS
        // ========================================
        function insertFormatting(textareaId, openTag, closeTag) {
            const textarea = document.getElementById(textareaId);
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const selectedText = textarea.value.substring(start, end);
            
            let newText;
            if (selectedText.length > 0) {
                // Wrap selected text
                newText = openTag + selectedText + closeTag;
            } else {
                // Insert tags at cursor position
                newText = openTag + closeTag;
            }
            
            textarea.value = textarea.value.substring(0, start) + newText + textarea.value.substring(end);
            
            // Position cursor
            if (selectedText.length > 0) {
                textarea.setSelectionRange(start, start + newText.length);
            } else {
                textarea.setSelectionRange(start + openTag.length, start + openTag.length);
            }
            
            textarea.focus();
        }

        function applySizeFormatting(textareaId, fontSize) {
            const size = parseInt(fontSize) || 16;
            insertFormatting(textareaId, `[SIZE=${size}]`, '[/SIZE]');
        }

        function closeTextModal() {
            app.closeTextModal();
        }

        function saveNodeProperties() {
            app.saveNodeProperties();
        }

        // ========================================
        // APPLICATION INITIALIZATION
        // ========================================
        let app;
        document.addEventListener('DOMContentLoaded', () => {
            app = new SyntacticTreeApp();
        });
    </script>
</body>
</html>